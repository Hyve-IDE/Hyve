// Copyright 2026 Hyve. All rights reserved.
package com.hyve.ui.core.domain.elements

import com.hyve.ui.core.domain.UIDocument
import com.hyve.ui.core.domain.properties.PropertyMap
import com.hyve.ui.core.domain.properties.PropertyValue
import com.hyve.ui.core.id.ElementId
import com.hyve.ui.core.id.ElementType
import com.hyve.ui.core.result.Result
import com.hyve.ui.exporter.UIExporter
import com.hyve.ui.parser.UIParser
import com.hyve.ui.state.EditDeltaTracker
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

/**
 * Tests for the auto-ID assignment system.
 *
 * Covers:
 * 1. AutoIdAssigner: deterministic ID assignment for ID-less elements
 * 2. UIExporter: auto-IDs stripped from exported text
 * 3. EditDeltaTracker: structural deltas work with auto-IDs
 * 4. Integration: full reparent cycle on ID-less elements
 */
class AutoIdAssignerTest {

    // =====================================================================
    // Helpers
    // =====================================================================

    private fun element(
        type: String,
        id: String? = null,
        vararg children: UIElement
    ): UIElement = UIElement(
        type = ElementType(type),
        id = id?.let { ElementId(it) },
        properties = PropertyMap.empty(),
        children = children.toList()
    )

    private fun elementWithProps(
        type: String,
        id: String? = null,
        props: PropertyMap = PropertyMap.empty(),
        vararg children: UIElement
    ): UIElement = UIElement(
        type = ElementType(type),
        id = id?.let { ElementId(it) },
        properties = props,
        children = children.toList()
    )

    private fun document(root: UIElement): UIDocument = UIDocument(
        imports = emptyMap(),
        styles = emptyMap(),
        root = root
    )

    private fun parseDoc(source: String): UIDocument {
        val parser = UIParser(source)
        val result = parser.parse()
        assertThat(result.isSuccess()).`as`("Parse should succeed").isTrue()
        return (result as Result.Success).value
    }

    private fun export(doc: UIDocument): String {
        val exporter = UIExporter()
        val result = exporter.export(doc)
        assertThat(result.isSuccess()).`as`("Export should succeed").isTrue()
        return (result as Result.Success).value
    }

    // =====================================================================
    // 1. AutoIdAssigner: basic behavior
    // =====================================================================

    @Test
    fun `assigns auto-IDs to elements without IDs`() {
        val tree = element("Root", null,
            element("Group"),
            element("Label"),
            element("Button")
        )

        val result = tree.assignAutoIds()

        // Root should get an auto-ID
        assertThat(result.id).isNotNull
        assertThat(result.id!!.isAutoGenerated()).isTrue()

        // All children should get auto-IDs
        result.children.forEach { child ->
            assertThat(child.id).isNotNull
            assertThat(child.id!!.isAutoGenerated()).isTrue()
        }
    }

    @Test
    fun `preserves existing IDs`() {
        val tree = element("Root", "MyRoot",
            element("Group", "MyGroup"),
            element("Label")  // no ID
        )

        val result = tree.assignAutoIds()

        assertThat(result.id).isEqualTo(ElementId("MyRoot"))
        assertThat(result.children[0].id).isEqualTo(ElementId("MyGroup"))
        // Label should get auto-ID
        assertThat(result.children[1].id!!.isAutoGenerated()).isTrue()
    }

    @Test
    fun `auto-IDs use correct prefix`() {
        val tree = element("Group")

        val result = tree.assignAutoIds()

        assertThat(result.id!!.value).startsWith(AUTO_ID_PREFIX)
    }

    @Test
    fun `auto-IDs include element type for debuggability`() {
        val tree = element("Root", "Root",
            element("Group"),
            element("Label"),
            element("Button")
        )

        val result = tree.assignAutoIds()

        assertThat(result.children[0].id!!.value).contains("Group")
        assertThat(result.children[1].id!!.value).contains("Label")
        assertThat(result.children[2].id!!.value).contains("Button")
    }

    @Test
    fun `auto-IDs are deterministic - same tree produces same IDs`() {
        val tree = element("Root", null,
            element("Group", null,
                element("Label"),
                element("Button")
            ),
            element("Label")
        )

        val result1 = tree.assignAutoIds()
        val result2 = tree.assignAutoIds()

        // All IDs should match between the two runs
        assertThat(result1.id).isEqualTo(result2.id)
        assertThat(result1.children[0].id).isEqualTo(result2.children[0].id)
        assertThat(result1.children[0].children[0].id).isEqualTo(result2.children[0].children[0].id)
        assertThat(result1.children[0].children[1].id).isEqualTo(result2.children[0].children[1].id)
        assertThat(result1.children[1].id).isEqualTo(result2.children[1].id)
    }

    @Test
    fun `auto-IDs are unique across entire tree`() {
        val tree = element("Root", null,
            element("Group", null,
                element("Label"),
                element("Label"),
                element("Label")
            ),
            element("Group", null,
                element("Button"),
                element("Button")
            )
        )

        val result = tree.assignAutoIds()

        val allIds = mutableListOf<String>()
        result.visitDescendants { el ->
            el.id?.let { allIds.add(it.value) }
        }

        assertThat(allIds).doesNotHaveDuplicates()
    }

    @Test
    fun `depth-first counter increments correctly`() {
        val tree = element("Root", null,
            element("A"),
            element("B", null,
                element("C"),
                element("D")
            ),
            element("E")
        )

        val result = tree.assignAutoIds()

        // Depth-first order: Root(0), A(1), B(2), C(3), D(4), E(5)
        val ids = mutableListOf<String>()
        result.visitDescendants { el ->
            if (el.id!!.isAutoGenerated()) {
                ids.add(el.id!!.value)
            }
        }

        // All should be auto-generated (since none had IDs)
        assertThat(ids).hasSize(6)
        // Counter should be sequential
        for (i in 0 until ids.size - 1) {
            val num1 = ids[i].substringAfterLast("_").toInt()
            val num2 = ids[i + 1].substringAfterLast("_").toInt()
            assertThat(num2).isGreaterThan(num1)
        }
    }

    @Test
    fun `mixed IDs - only ID-less elements get auto-IDs`() {
        val tree = element("Root", "Root",
            element("Group", "Header"),
            element("Label"),             // no ID → auto
            element("Button", "Submit"),
            element("Group", null,        // no ID → auto
                element("Label", "Inner")
            )
        )

        val result = tree.assignAutoIds()

        assertThat(result.id!!.isAutoGenerated()).isFalse()
        assertThat(result.children[0].id!!.isAutoGenerated()).isFalse()
        assertThat(result.children[1].id!!.isAutoGenerated()).isTrue()
        assertThat(result.children[2].id!!.isAutoGenerated()).isFalse()
        assertThat(result.children[3].id!!.isAutoGenerated()).isTrue()
        assertThat(result.children[3].children[0].id!!.isAutoGenerated()).isFalse()
    }

    // =====================================================================
    // 2. UIExporter: auto-IDs stripped from output
    // =====================================================================

    @Test
    fun `exporter strips auto-IDs from elements`() {
        val source = """
            Group {
                Label {
                    Text: "Hello";
                }
            }
        """.trimIndent()

        val doc = parseDoc(source)
        val withAutoIds = doc.copy(root = doc.root.assignAutoIds())
        val exported = export(withAutoIds)

        // No auto-ID prefix should appear in exported text
        assertThat(exported).doesNotContain(AUTO_ID_PREFIX)
        // Should still have the element structure
        assertThat(exported).contains("Group {")
        assertThat(exported).contains("Label {")
        assertThat(exported).contains("Text: \"Hello\";")
    }

    @Test
    fun `exporter preserves real IDs alongside stripped auto-IDs`() {
        val source = """
            Group #Main {
                Label {
                    Text: "Hello";
                }
                Button #Submit {
                    Text: "OK";
                }
            }
        """.trimIndent()

        val doc = parseDoc(source)
        val withAutoIds = doc.copy(root = doc.root.assignAutoIds())
        val exported = export(withAutoIds)

        // Real IDs should be preserved
        assertThat(exported).contains("#Main")
        assertThat(exported).contains("#Submit")
        // Auto-IDs should NOT appear
        assertThat(exported).doesNotContain(AUTO_ID_PREFIX)
        // Label should export without an ID (it originally had none)
        assertThat(exported).contains("Label {")
        assertThat(exported).doesNotContain("Label #")
    }

    @Test
    fun `round-trip with auto-IDs produces clean output`() {
        val source = """
            Group {
                Label {
                    Text: "Hello";
                }
                Button {
                    Text: "Click";
                }
            }
        """.trimIndent()

        val doc = parseDoc(source)
        val withAutoIds = doc.copy(root = doc.root.assignAutoIds())
        val exported = export(withAutoIds)

        // Re-parse and re-export should be identical
        val reparsed = parseDoc(exported)
        val reExported = export(reparsed)

        assertThat(reExported).isEqualTo(exported)
    }

    // =====================================================================
    // 3. Delta tracker: structural deltas with auto-IDs
    // =====================================================================

    @Test
    fun `delete element with auto-ID via delta tracker`() {
        val tree = element("Root", "Root",
            element("Group"),
            element("Label"),
            element("Button")
        )
        val withAutoIds = tree.assignAutoIds()
        val doc = document(withAutoIds)

        val labelId = withAutoIds.children[1].id!!
        assertThat(labelId.isAutoGenerated()).isTrue()

        val tracker = EditDeltaTracker()
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))

        val result = tracker.applyTo(doc)

        assertThat(result.root.children).hasSize(2)
        assertThat(result.root.children.none { it.id == labelId }).isTrue()
    }

    @Test
    fun `move element with auto-ID between parents via delta tracker`() {
        val tree = element("Root", "Root",
            element("Group", "Panel1",
                element("Label"),
                element("Button")
            ),
            element("Group", "Panel2")
        )
        val withAutoIds = tree.assignAutoIds()
        val doc = document(withAutoIds)

        val labelId = withAutoIds.children[0].children[0].id!!
        val labelElement = withAutoIds.children[0].children[0]
        assertThat(labelId.isAutoGenerated()).isTrue()

        val tracker = EditDeltaTracker()
        // Delete from Panel1
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))
        // Add to Panel2
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = ElementId("Panel2"),
            index = 0,
            element = labelElement
        ))

        val result = tracker.applyTo(doc)

        val panel1 = result.findElementById(ElementId("Panel1"))
        assertThat(panel1!!.children).hasSize(1) // Only Button remains
        assertThat(panel1.children[0].id!!.isAutoGenerated()).isTrue()

        val panel2 = result.findElementById(ElementId("Panel2"))
        assertThat(panel2!!.children).hasSize(1)
        assertThat(panel2.children[0].id).isEqualTo(labelId)
    }

    @Test
    fun `reparent auto-ID element into newly created group via deltas`() {
        val tree = element("Root", "Root",
            element("Label"),
            element("Button")
        )
        val withAutoIds = tree.assignAutoIds()
        val doc = document(withAutoIds)

        val labelId = withAutoIds.children[0].id!!
        val labelElement = withAutoIds.children[0]

        // Create a new group
        val newGroup = UIElement(
            type = ElementType("Group"),
            id = ElementId("NewGroup"),
            properties = PropertyMap.empty()
        )

        val tracker = EditDeltaTracker()
        // Add the new group at root level
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = null,
            index = 2,
            element = newGroup
        ))
        // Delete the label from root
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))
        // Add the label to the new group
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = ElementId("NewGroup"),
            index = 0,
            element = labelElement
        ))

        val result = tracker.applyTo(doc)

        // Root should have Button and NewGroup (Label moved into NewGroup)
        assertThat(result.root.children).hasSize(2)

        val group = result.findElementById(ElementId("NewGroup"))
        assertThat(group).isNotNull
        assertThat(group!!.children).hasSize(1)
        assertThat(group.children[0].id).isEqualTo(labelId)
    }

    // =====================================================================
    // 4. Integration: full parse → auto-ID → delta → export cycle
    // =====================================================================

    @Test
    fun `full cycle - reparent ID-less element preserves in export`() {
        val source = """
            Group #Root {
                Label {
                    Text: "Hello";
                }
                Button {
                    Text: "Click";
                }
            }
        """.trimIndent()

        // Step 1: Parse and assign auto-IDs (simulating editor load)
        val rawDoc = parseDoc(source).let { doc ->
            doc.copy(root = doc.root.assignAutoIds())
        }

        val labelId = rawDoc.root.children[0].id!!
        val labelElement = rawDoc.root.children[0]
        assertThat(labelId.isAutoGenerated()).isTrue()

        // Step 2: Create a new group and reparent the label into it
        val newGroup = UIElement(
            type = ElementType("Group"),
            id = ElementId("Wrapper"),
            properties = PropertyMap.empty()
        )

        val tracker = EditDeltaTracker()
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = ElementId("Root"),
            index = 2,
            element = newGroup
        ))
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = ElementId("Wrapper"),
            index = 0,
            element = labelElement
        ))

        // Step 3: Apply deltas and export
        val withDeltas = tracker.applyTo(rawDoc)
        val exported = export(withDeltas)

        // Step 4: Verify export
        assertThat(exported).doesNotContain(AUTO_ID_PREFIX)
        assertThat(exported).contains("#Wrapper")
        // The Label should be inside the Wrapper group
        assertThat(exported).contains("Group #Wrapper {")
        assertThat(exported).contains("Text: \"Hello\";")
        // Button should still be at root level (under Group #Root)
        assertThat(exported).contains("Text: \"Click\";")

        // Step 5: Re-parse and assign auto-IDs again (simulating reload)
        val reparsedDoc = parseDoc(exported).let { doc ->
            doc.copy(root = doc.root.assignAutoIds())
        }

        // The Wrapper group should have the Label as a child
        val wrapper = reparsedDoc.findElementById(ElementId("Wrapper"))
        assertThat(wrapper).isNotNull
        assertThat(wrapper!!.children).hasSize(1)
        assertThat(wrapper.children[0].type.value).isEqualTo("Label")
    }

    @Test
    fun `full cycle - wrap-in-group on ID-less element preserves in export`() {
        val source = """
            Group #Root {
                Label {
                    Text: "Wrapped";
                }
                Button #Keep {
                    Text: "Stay";
                }
            }
        """.trimIndent()

        val rawDoc = parseDoc(source).let { doc ->
            doc.copy(root = doc.root.assignAutoIds())
        }

        val labelId = rawDoc.root.children[0].id!!
        val labelElement = rawDoc.root.children[0]

        // Simulate wrap-in-group
        val wrapGroup = UIElement(
            type = ElementType("Group"),
            id = ElementId("WrapGroup"),
            properties = labelElement.properties,
            children = listOf(labelElement.copy(
                properties = PropertyMap.of(
                    "Text" to PropertyValue.Text("Wrapped")
                )
            ))
        )

        val tracker = EditDeltaTracker()
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))
        tracker.record(EditDeltaTracker.EditDelta.AddElement(
            parentId = ElementId("Root"),
            index = 0,
            element = wrapGroup
        ))

        val withDeltas = tracker.applyTo(rawDoc)
        val exported = export(withDeltas)

        // Verify
        assertThat(exported).doesNotContain(AUTO_ID_PREFIX)
        assertThat(exported).contains("Group #WrapGroup {")
        assertThat(exported).contains("#Keep")
    }

    @Test
    fun `auto-IDs are consistent between two independent assignAutoIds calls on same structure`() {
        // This simulates the dual-parse: raw and resolved documents
        // must get the same auto-IDs for matching elements
        val source = """
            Group {
                Label {
                    Text: "A";
                }
                Button {
                    Text: "B";
                }
            }
        """.trimIndent()

        val doc1 = parseDoc(source).let { it.copy(root = it.root.assignAutoIds()) }
        val doc2 = parseDoc(source).let { it.copy(root = it.root.assignAutoIds()) }

        // Collect all IDs from both trees
        val ids1 = mutableListOf<ElementId>()
        doc1.root.visitDescendants { ids1.add(it.id!!) }

        val ids2 = mutableListOf<ElementId>()
        doc2.root.visitDescendants { ids2.add(it.id!!) }

        assertThat(ids1).isEqualTo(ids2)
    }

    @Test
    fun `deleting an ID-less element from export removes it from output`() {
        val source = """
            Group #Root {
                Label {
                    Text: "Delete me";
                }
                Button #Keep {
                    Text: "Stay";
                }
            }
        """.trimIndent()

        val rawDoc = parseDoc(source).let { doc ->
            doc.copy(root = doc.root.assignAutoIds())
        }

        val labelId = rawDoc.root.children[0].id!!

        val tracker = EditDeltaTracker()
        tracker.record(EditDeltaTracker.EditDelta.DeleteElement(elementId = labelId))

        val withDeltas = tracker.applyTo(rawDoc)
        val exported = export(withDeltas)

        assertThat(exported).doesNotContain("Delete me")
        assertThat(exported).contains("Stay")
        assertThat(exported).doesNotContain(AUTO_ID_PREFIX)
    }
}
